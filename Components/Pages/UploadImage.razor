@page "/serversignalr"
@using Azure
@using Azure.AI.Vision.ImageAnalysis
@using System.Net
@inject IWebHostEnvironment env
@* @inject BlobServiceClient blobClient *@
@using System
@inject IConfiguration Configuration
@rendermode InteractiveServer
@using PruebaAnalisisDeImagen.Data

<div>
    <h2 class="display-4">Registro de cobros interbancarios</h2>
    Carga el archivo de registro.
</div>

@if (Message.Length > 0)
{
    <p class="alert alert-secondary" role="alert">@Message</p>
}

<EditForm Model="@Ticket" method="post" OnValidSubmit="@OnSubmit" enctype="multipart/form-data">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <InputFile class="form-control mb-4" OnChange="@SetFile" multiple />
    <button class="btn btn-primary" type="submit">Confirmar</button>
</EditForm>
@if (imageUploaded)
{
    @if (succesfulWords == 4 && CompareWithSystemDate())
    {
        <div>
            <h1>Validado exitosamente</h1>
        </div>
    }
    else
    {
        <div>
            <h1>No se pudo validar exitosamente</h1>
        </div>
    }

}

@code {
    private ServerSignalRTicket Ticket { get; set; } = new();
    private long maxFileSize = 5120000; 
    private string Message { get; set; } = String.Empty;
    private List<string> analysisResult = new List<string>();
    private List<string> elementsToStore = new List<string>();
    private int succesfulWords = 0;
    private string extractedDate;
    private int iii = 0;
    private bool imageUploaded = false;

    private void SetFile(InputFileChangeEventArgs e)
    {
        Ticket.Attachments = e.GetMultipleFiles();
    }

    private async Task OnSubmit()
    {
        try
        {
            foreach (var file in    Ticket.Attachments)
            {
                string safeFileName = WebUtility.HtmlEncode(file.Name);

                // Save file locally
                var path = Path.Combine(env.ContentRootPath, "images", safeFileName);
                await using FileStream fs = new(path, FileMode.Create);
                await file.OpenReadStream(maxFileSize).CopyToAsync(fs);
                long fileSize = fs.Length;
                Console.WriteLine(fileSize);
                fs.Position = 0;
                AnalyzeImage(fs);
                CompareWithFixedData(["confirmado", "satisfactoriamente", "registrado", "exitosamente"]);
                imageUploaded = true;
                fs.Close();
                File.Delete(path);

            }

            Message = "File uploaded!";
        }
        catch (Exception e)
        {
            Message = "Error: " + e.Message;
        }
    }

    private void AnalyzeImage(FileStream imageFileStream)
    {
        string endpoint = Configuration["AzureVisionEndpoint"];
        string key = Configuration["AzureVisionKey"];

        ImageAnalysisClient client = new ImageAnalysisClient(
            new Uri(endpoint),
            new AzureKeyCredential(key));

        // using FileStream stream = new FileStream("pruebavision.png", FileMode.Open);
        FileStream stream = imageFileStream;
        BinaryData imageData = BinaryData.FromStream(stream);

        VisualFeatures visualFeatures =
            VisualFeatures.Caption |
            VisualFeatures.Read;

        ImageAnalysisOptions options = new ImageAnalysisOptions
            {
                GenderNeutralCaption = true,
                Language = "en",
            };

        ImageAnalysisResult result = client.Analyze(
            imageData,
            visualFeatures,
            options);


        foreach (DetectedTextBlock block in result.Read.Blocks)
        {
            foreach (DetectedTextLine line in block.Lines)
            {
                foreach (DetectedTextWord word in line.Words)
                {
                    analysisResult.Add(word.Text);
                }

            }
        }
        foreach (string word in analysisResult)
        {
            Console.WriteLine($"{iii}: '{word}'");
            iii++;
        }
        FetchData();


    }

    private void CompareWithFixedData(string[] fixedData)
    {
        List<bool> comparisonResults = new List<bool>();


        for (int i = 0; i < fixedData.Length && i < analysisResult.Count; i++)
        {
            comparisonResults.Add(fixedData[i] == analysisResult[i]);
            succesfulWords++;
        }

    }

    private bool CompareWithSystemDate()
    {
        if (analysisResult.Count == 0)
        {
            throw new InvalidOperationException("El elemento está vacío");
        }

        string imageDate = "10/07/2024"; //imagedto.fecha; //"07/10/2024"
        Console.WriteLine(imagedto.fecha);
        if (DateTime.TryParseExact(imageDate, "dd/MM/yyyy", null, System.Globalization.DateTimeStyles.None, out DateTime extractedDate))
        {
            DateTime systemDate = DateTime.Now.Date;
            return extractedDate==systemDate;
        }
        else
        {
            throw new FormatException("The last element is not in a valid date format.");
        }
    }

    private string connectionString = "Host=192.168.137.22:5432;Username=postgres;Password=1234;Database=prueba18";
    private imageDto imagedto = new imageDto();

    private void FetchData()
    {
        string pattern = @"\b\d{2}/\d{2}/\d{4}\b";
        string processPattern = @"S[CP]I[1-3]";
        const int numElementsToStore = 3;
        bool processFound = false;


        for (int i = 0; i < analysisResult.Count; i++)
        {
            string str = analysisResult[i];
            MatchCollection matches = Regex.Matches(str, pattern);
            MatchCollection processMatches = Regex.Matches(str, processPattern);

            if (processMatches.Count > 0 && !processFound)
            {
                elementsToStore.Add(str);
                Console.WriteLine("aaaaaaaaaa" + str);
                processFound = true;

            }

            if (matches.Count > 0)
            {
                // Verificar el elemento anterior y el siguiente
                bool previousIsDigit = i > 0 && IsDigit(analysisResult[i - 1]);
                bool nextIsDigit = i < analysisResult.Count - 1 && IsDigit(analysisResult[i + 1]);

                if (previousIsDigit && nextIsDigit)
                {
                    // Almacenar el match y los siguientes elementos en la base de datos
                    //List<string> elementsToStore = new List<string>();
                    elementsToStore.Add(analysisResult[i - 1]);
                    elementsToStore.Add(str); // Agregar el match actual

                    // Agregar los siguientes cinco elementos si existen
                    for (int j = 1; j <= numElementsToStore - 1 && (i + j) < analysisResult.Count; j++)
                    {
                        elementsToStore.Add(analysisResult[i + j]);
                    }
                }

            }

        }

        imagedto.corte = elementsToStore[1];
        imagedto.fecha = elementsToStore[2];
        imagedto.opis = elementsToStore[3];
        imagedto.monto = elementsToStore[4];
        imagedto.archivo = elementsToStore[0];


        using (var context = new ImageDbContext())
        {
            context.Database.EnsureCreated(); // Crear la base de datos si no existe

            // Crear un nuevo objeto imageDto y asignarle los valores
            var newImage = new imageDto
                {
                    corte = elementsToStore.Count > 0 ? elementsToStore[1] : null,
                    fecha = elementsToStore.Count > 1 ? elementsToStore[2] : null,
                    opis = elementsToStore.Count > 2 ? elementsToStore[3] : null,
                    monto = elementsToStore.Count > 3 ? elementsToStore[4] : null,
                    archivo = elementsToStore.Count > 4 ? elementsToStore[0] : null
                };

            // Agregar el nuevo objeto a DbSet y guardar los cambios en la base de datos
            context.ImgData.Add(newImage);
            context.SaveChanges();
            checkdatabase(context);
        }
    }

    private async void checkdatabase(ImageDbContext db)
    {
        var results = from image in db.ImgData
                      select image;

        await foreach (var s in results.AsAsyncEnumerable())
        {
            Console.WriteLine("datos " + s.fecha);
        }
    }
    private bool IsDigit(string str)
    {   
        if (str == null) return false;

        foreach (char c in str)
        {
            if (!char.IsDigit(c))
            {
                return false;
            }
        }
        return true;
    }



    private class ServerSignalRTicket
    {

        public IReadOnlyList<IBrowserFile> Attachments { get; set; }
    }
}