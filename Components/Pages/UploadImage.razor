@page "/serversignalr"
@using Azure
@using Azure.AI.Vision.ImageAnalysis
@using System.Net
@inject IWebHostEnvironment env
@* @inject BlobServiceClient blobClient *@
@using System
@inject IConfiguration Configuration
@rendermode InteractiveServer
@using PruebaAnalisisDeImagen.Components.UIElements
@using PruebaAnalisisDeImagen.Data
@using PruebaAnalisisDeImagen.Models

<div>
    <h2 class="display-4">Registro de cobros interbancarios</h2>
    Carga el archivo de registro.
</div>

@if (Message.Length > 0)
{
    <p class="alert alert-secondary" role="alert">@Message</p>
}

<EditForm Model="@Ticket" method="post" OnValidSubmit="@OnSubmit" enctype="multipart/form-data">
    <DataAnnotationsValidator />
    <ValidationSummary />
    <InputFile class="form-control mb-4" OnChange="@SetFile" multiple />
    <button class="btn btn-primary" type="submit">Confirmar</button>
</EditForm>


@if (imageUploaded)
{
    <MessageValidation SuccesfulWords="@succesfulWords" CompareDate="@succesfulDate" />
    @if (elementsToStore.Count > 0)
    {
        <TableComponent elementsToStore="@elementsToStore" />
    }
   
}


@code {
    private ServerSignalRTicket Ticket { get; set; } = new();
    private long maxFileSize = 5120000; 
    private string Message { get; set; } = String.Empty;
    private List<string> analysisResult = new List<string>();
    private List<string> elementsToStore = new List<string>();
    private int succesfulWords = 0;
    private bool succesfulDate = false;
    private string extractedDate;
    private int iii = 0;
    private bool imageUploaded = false;
    private int indice = 0;
    private ImageDTO imagedto = new ImageDTO();

    private void SetFile(InputFileChangeEventArgs e)
    {
        Ticket.Attachment = e.File;

    }

    private async Task OnSubmit()
    {

        try
        {
            //Reiniciar estado del sistema para cargar mas de una imagen 
            imageUploaded = false;
            succesfulWords = 0;
            analysisResult.Clear();
            elementsToStore.Clear();

            string safeFileName = WebUtility.HtmlEncode(Ticket.Attachment.Name);

            // Save file locally
            var path = Path.Combine(env.ContentRootPath, "images", safeFileName);
            await using FileStream fs = new(path, FileMode.Create);
            await Ticket.Attachment.OpenReadStream(maxFileSize).CopyToAsync(fs);
            long fileSize = fs.Length;
            Console.WriteLine(fileSize);
            fs.Position = 0;
            AnalyzeImage(fs);
            CompareWithFixedData(["confirmado", "satisfactoriamente", "registrado", "exitosamente"]);
            CompareWithSystemDate();
            var hhhh = handleSPI();
            Console.WriteLine(hhhh);
            imageUploaded = true;
            fs.Close();
            File.Delete(path);
            indice++; //borrar pq es de la fecha de prueba



            Message = "¡Archivo cargado!";
        }
        catch (Exception e)
        {
            Message = "Error: " + e.Message;
        }
    }

    private void AnalyzeImage(FileStream imageFileStream)
    {
        string endpoint = Configuration["AzureVisionEndpoint"];
        string key = Configuration["AzureVisionKey"];

        ImageAnalysisClient client = new ImageAnalysisClient(
            new Uri(endpoint),
            new AzureKeyCredential(key));

        // using FileStream stream = new FileStream("pruebavision.png", FileMode.Open);
        FileStream stream = imageFileStream;
        BinaryData imageData = BinaryData.FromStream(stream);

        VisualFeatures visualFeatures =
            VisualFeatures.Caption |
            VisualFeatures.Read;

        ImageAnalysisOptions options = new ImageAnalysisOptions
            {
                GenderNeutralCaption = true,
                Language = "en",
            };

        ImageAnalysisResult result = client.Analyze(
            imageData,
            visualFeatures,
            options);


        foreach (DetectedTextBlock block in result.Read.Blocks)
        {
            foreach (DetectedTextLine line in block.Lines)
            {
                foreach (DetectedTextWord word in line.Words)
                {
                    analysisResult.Add(word.Text);
                }

            }
        }
        foreach (string word in analysisResult)
        {
            Console.WriteLine($"{iii}: '{word}'");
            iii++;
        }
        FetchData();


    }

    private void CompareWithFixedData(string[] fixedData)
    {
        List<bool> comparisonResults = new List<bool>();


        for (int i = 0; i < fixedData.Length && i < analysisResult.Count; i++)
        {
            comparisonResults.Add(fixedData[i] == analysisResult[i]);
            succesfulWords++;
        }

    }

    private bool CompareWithSystemDate()
    {

        //string imageDate = "12/07/2024"; //imagedto.fecha; //"07/10/2024"
        string[] numeros = new string[] { "12/07/2024", "13/07/2024" };

        Console.WriteLine(imagedto.fecha);
        if (DateTime.TryParseExact(numeros[indice], "dd/MM/yyyy", null, System.Globalization.DateTimeStyles.None, out DateTime extractedDate))
        {
            DateTime systemDate = DateTime.Now.Date;
            succesfulDate = extractedDate==systemDate;
            return succesfulDate;
        }
        else
        {
            throw new FormatException("The last element is not in a valid date format.");
        }
    }






    private string connectionString = "Host=192.168.137.22:5432;Username=postgres;Password=1234;Database=prueba18";


    private void FetchData()
    {
        string pattern = @"\b\d{2}/\d{2}/\d{4}\b";
        string processPattern = @"S[CP]I[1-3]";
        const int numElementsToStore = 3;
        bool processFound = false;


        for (int i = 0; i < analysisResult.Count; i++)
        {
            string str = analysisResult[i];
            MatchCollection matches = Regex.Matches(str, pattern);
            MatchCollection processMatches = Regex.Matches(str, processPattern);

            if (processMatches.Count > 0 && !processFound)
            {
                elementsToStore.Add(str);
                processFound = true;

            }

            if (matches.Count > 0)
            {
                // Verificar el elemento anterior y el siguiente
                bool previousIsDigit = i > 0 && IsDigit(analysisResult[i - 1]);
                bool nextIsDigit = i < analysisResult.Count - 1 && IsDigit(analysisResult[i + 1]);

                if (previousIsDigit && nextIsDigit)
                {
                    // Almacenar el match y los siguientes elementos en la base de datos
                    //List<string> elementsToStore = new List<string>();
                    elementsToStore.Add(analysisResult[i - 1]); //agregar corte
                    elementsToStore.Add(str); // Agregar el match actual

                    // Agregar los siguientes cinco elementos si existen
                    for (int j = 1; j <= numElementsToStore - 1 && (i + j) < analysisResult.Count; j++)
                    {
                        elementsToStore.Add(analysisResult[i + j]);
                    }
                }

            }

        }

        imagedto.corte = elementsToStore[1];
        imagedto.fecha = elementsToStore[2];
        imagedto.opis = elementsToStore[3];
        imagedto.monto = elementsToStore[4];
        imagedto.archivo = elementsToStore[0];


        using (var context = new ImageDbContext())
        {
            context.Database.EnsureCreated(); // Crear la base de datos si no existe

            // Crear un nuevo objeto imageDto y asignarle los valores
            var newImage = new ImageDTO
                {
                    corte = elementsToStore.Count > 0 ? elementsToStore[1] : null,
                    fecha = elementsToStore.Count > 1 ? elementsToStore[2] : null,
                    opis = elementsToStore.Count > 2 ? elementsToStore[3] : null,
                    monto = elementsToStore.Count > 3 ? elementsToStore[4] : null,
                    archivo = elementsToStore.Count > 4 ? elementsToStore[0] : null
                };

            // Agregar el nuevo objeto a DbSet y guardar los cambios en la base de datos
            context.ImgData.Add(newImage);
            context.SaveChanges();
            checkdatabase(context);
        }
    }

    private async void checkdatabase(ImageDbContext db)
    {
        var results = from image in db.ImgData
                      select image;

        await foreach (var s in results.AsAsyncEnumerable())
        {
            Console.WriteLine("datos " + s.fecha);
        }
    }
    private bool IsDigit(string str)
    {   
        if (str == null) return false;

        foreach (char c in str)
        {
            if (!char.IsDigit(c))
            {
                return false;
            }
        }
        return true;
    }


    private void triggerSCIorSPIAnalysis()
    {
        if (imagedto.archivo.ToLower().Contains(Constants.SPI))
        {

        }
        else if (imagedto.archivo.ToLower().Contains(Constants.SCI))
        {
            //logica para manaejar SCI
        }
        else
        {
            //logica por si no es ninguna de los dos 
        }
    }


    private void handleSCI()
    {

    }

    private bool handleSPI()
    {
        DateTime horaActual = DateTime.Now;
        TimeSpan horaInicio;
        TimeSpan horaFin;

        var horariosSPI1 = new Dictionary<string, (TimeSpan inicio, TimeSpan fin)>
    {
        { "1", (new TimeSpan(8, 0, 0), new TimeSpan(9, 0, 0)) },
        { "2", (new TimeSpan(13, 0, 0), new TimeSpan(14, 0, 0)) },
        { "3", (new TimeSpan(17, 0, 0), new TimeSpan(18, 0, 0)) }
    };

        var horariosSPI3 = new Dictionary<string, (TimeSpan inicio, TimeSpan fin)>
    {
        { "1", (new TimeSpan(9, 0, 0), new TimeSpan(11, 0, 0)) },
        { "2", (new TimeSpan(14, 0, 0), new TimeSpan(15, 0, 0)) },
        { "3", (new TimeSpan(17, 0, 0), new TimeSpan(19, 0, 0)) }
    };

        Dictionary<string, (TimeSpan inicio, TimeSpan fin)> horarios;

        switch (imagedto.archivo)
        {
            case "SPI1":
                horarios = horariosSPI1;
                break;
            case "SPI3":
                horarios = horariosSPI3;
                break;
            default:
                throw new ArgumentException("Invalid 'archivo' value");
        }

        if (!horarios.TryGetValue(imagedto.corte, out var horario))
        {
            throw new ArgumentException($"Invalid 'corte' value for {imagedto.archivo}");
        }

        horaInicio = horario.inicio;
        horaFin = horario.fin;

        return (horaActual.TimeOfDay >= horaInicio && horaActual.TimeOfDay <= horaFin);
    }



    private class ServerSignalRTicket
    {

        public IBrowserFile Attachment { get; set; }
    }
}